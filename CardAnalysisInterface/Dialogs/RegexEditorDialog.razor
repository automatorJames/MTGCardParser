@using System.Text.RegularExpressions
@using System.Linq
@inject IJSRuntime JsRuntime
@implements IAsyncDisposable

<CustomDialog OnBackdropClick="Cancel">
    <DialogContent>
        <div style="display:flex; align-items:baseline;">
            <span style="color: #A0AEC0; font-weight: 500; font-size: 28px; margin-bottom: 12px;">
                @Line.Card.Name
            </span>
            <span style="color: #718096; margin-left: auto; font-size: 0.8em;">
                @($"Line #{Line.LineIndex + 1}")
            </span>
        </div>
        <div style="display: flex; flex-direction: column; gap: 16px;">

            <div class="line-text-container">
                <div class="text-layer-back">
                    @{
                        int cursor = 0;
                        foreach (var match in _currentMatches.OrderBy(m => m.Index))
                        {
                            if (match.Index > cursor)
                            {
                                @Line.SourceText.Substring(cursor, match.Index - cursor)
                            }
                            <span class="highlight-token">@match.Value</span>
                            cursor = match.Index + match.Length;
                        }
                        if (cursor < Line.SourceText.Length)
                        {
                            @Line.SourceText.Substring(cursor)
                        }
                    }

                    <div class="text-layer-front">
                        @{
                            cursor = 0;
                            foreach (var token in Line.SourceTokens.OrderBy(t => t.Span.Position.Absolute))
                            {
                                if (token.Span.Position.Absolute > cursor)
                                {
                                    @Line.SourceText.Substring(cursor, token.Span.Position.Absolute - cursor)
                                }

                                var tokenText = Line.SourceText.Substring(token.Span.Position.Absolute, token.Span.Length);
                                var color = token.Kind == typeof(DefaultUnmatchedString) ? "lightgray" : TokenTypeRegistry.TypeColorPalettes[token.Kind].Hex;
                                <span style=@($"color: {color}")>@tokenText</span>
                                cursor = token.Span.Position.Absolute + token.Span.Length;
                            }

                            if (cursor < Line.SourceText.Length)
                            {
                                @Line.SourceText.Substring(cursor)
                            }
                        }
                    </div>
                </div>
            </div>

            <div>
                <label for="regex-input-field">Regular expression template</label>
                <input value="@_newRegexPattern"
                       @oninput="OnRegexInput"
                       class="form-control"
                       placeholder="Apply a new regular expression"
                       id="regex-input-field"
                       autocomplete="off" />
            </div>
        </div>
    </DialogContent>
    <DialogActions>
        <button class="btn btn-secondary" @onclick="Cancel">Cancel</button>
        <button class="btn btn-primary" @onclick="Submit">Save</button>
    </DialogActions>
</CustomDialog>

@code {
    [Parameter]
    public CardLine Line { get; set; }

    [Parameter]
    public EventCallback<string> OnClose { get; set; }

    private string _newRegexPattern = "";
    private List<Match> _currentMatches = new List<Match>();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Register the keydown listener for the 'Escape' key.
            await JsRuntime.InvokeVoidAsync("registerDialogKeyListener", DotNetObjectReference.Create(this));

            // Set focus on the input field.
            await JsRuntime.InvokeVoidAsync("focusElement", "regex-input-field");
        }
    }

    [JSInvokable]
    public Task HandleEscapeKeyPress()
    {
        return Cancel();
    }

    private void OnRegexInput(ChangeEventArgs e)
    {
        _newRegexPattern = e.Value?.ToString() ?? "";

        if (string.IsNullOrEmpty(_newRegexPattern))
        {
            _currentMatches.Clear();
        }
        else
        {
            try
            {
                _currentMatches = Regex.Matches(Line.SourceText, _newRegexPattern)
                                       .Cast<Match>()
                                       .ToList();
            }
            catch (RegexParseException)
            {
                _currentMatches.Clear();
            }
        }
    }

    private Task Submit() => OnClose.InvokeAsync(_newRegexPattern);
    private Task Cancel() => OnClose.InvokeAsync(null);

    public async ValueTask DisposeAsync()
    {
        await JsRuntime.InvokeVoidAsync("disposeDialogKeyListener");
    }
}