@using System.Text.RegularExpressions
@using System.Linq
@inject IJSRuntime JsRuntime
@implements IAsyncDisposable

<CustomDialog OnBackdropClick="HandleCancel">
    <DialogContent>
        <div style="display:flex; align-items:baseline;">
            <span style="color: #A0AEC0; font-weight: 500; font-size: 28px; margin-bottom: 12px;">
                @Line.Card.Name
            </span>
            <span class="small-box-label">@($"Line #{Line.LineIndex + 1}")</span>
        </div>
        <div style="display: flex; flex-direction: column; gap: 16px;">

            <div class="line-text-container">
                <!-- The back layer is now the single child that controls height. -->
                <div class="text-layer-back">
                    @{
                        int cursor = 0;
                        foreach (var match in _currentMatches.OrderBy(m => m.Index))
                        {
                            if (match.Index > cursor)
                            {
                                @Line.SourceText.Substring(cursor, match.Index - cursor)
                            }
                            <span class="highlight-token">@match.Value</span>
                            cursor = match.Index + match.Length;
                        }
                        if (cursor < Line.SourceText.Length)
                        {
                            @Line.SourceText.Substring(cursor)
                        }
                    }

                    <!-- The colored text layer is now NESTED inside the back layer. -->
                    <div class="text-layer-front">
                        @{
                            cursor = 0;
                            foreach (var token in Line.SourceTokens.OrderBy(t => t.Span.Position.Absolute))
                            {
                                if (token.Span.Position.Absolute > cursor)
                                {
                                    @Line.SourceText.Substring(cursor, token.Span.Position.Absolute - cursor)
                                }
                                var tokenText = Line.SourceText.Substring(token.Span.Position.Absolute, token.Span.Length);
                                var color = token.Kind == typeof(DefaultUnmatchedString) ? "lightgray" : TokenTypeRegistry.Palettes[token.Kind].HexLight;
                                <span style=@($"color: {color}")>@tokenText</span>
                                cursor = token.Span.Position.Absolute + token.Span.Length;
                            }
                            if (cursor < Line.SourceText.Length)
                            {
                                @Line.SourceText.Substring(cursor)
                            }
                        }
                    </div>
                </div>
            </div>

            <div>

                <div class="autocomplete-container">
                    <label for="regex-input-field">Regular expression template</label>
                    <div id="regex-input-field" class="regex-input-composite form-control" @onclick="FocusInputElement">
                        @foreach (var segment in _patternSegments)
                        {
                            if (segment.IsPill)
                            {
                                <Pill Text="@segment.DisplayText" OnDelete="() => DeletePill(segment.Id)" Color=@TokenTypeRegistry.Palettes[TokenTypeRegistry.NameToType[segment.DisplayText]].HexDark />
                            }
                            else
                            {
                                <span class="text-segment">@segment.DisplayText</span>
                            }
                        }
                        <input @ref="_inputElement"
                        id="regex-ghost-input"
                        class="ghost-input"
                        value="@_currentTypingText"
                        @oninput="OnTextInput"
                        @onkeydown="OnInputKeyDown"
                        @onblur="CommitTypingText"
                        placeholder="@(_patternSegments.Any() ? "" : "Type text or @ to see templates")"
                        autocomplete="off" />
                    </div>

                    @if (_isDropdownVisible)
                    {
                        <div id="autocomplete-dropdown-list" class="autocomplete-dropdown">
                            @foreach (var (suggestedType, index) in _autocompleteSuggestions.Select((s, i) => (s, i)))
                            {
                                <div id="@($"autocomplete-item-{index}")"
                                class="autocomplete-item @(index == _selectedSuggestionIndex ? "selected" : "")"
                                @onclick="() => SelectSuggestion(suggestedType)">
                                    <span class="type-name" style=@($"color: {TokenTypeRegistry.Palettes[suggestedType].Hex}; {(suggestedType.IsEnum ? "font-style: italic" : "normal")};")>@suggestedType.Name</span>
                                    <span class="type-kind">@(suggestedType.IsEnum ? "Enum" : "Token Type")</span>
                                </div>
                            }
                        </div>
                    }
                </div>

                @if (!string.IsNullOrEmpty(_renderedRegex))
                {
                    <br />
                    <br />

                    <div style="border-top: 1px dashed var(--outline-grey)" />

                    <br />

                    <div style="display: flex; flex-direction: column;">
                        <div class="small-box-label right">Rendered regex</div>
                        <div class="rendered-regex-box">
                            <pre>@_renderedRegex</pre>
                        </div>

                        <br />

                        <div class="small-box-label right">C# class preview</div>
                        <div class="rendered-regex-box">
                            <pre class="c-sharp">@_tokenTemplatePreview.ClassFileStyled</pre>
                        </div>
                    </div>
                }
            </div>
        </div>
    </DialogContent>
    <DialogActions>
        <button class="btn btn-secondary" @onclick="HandleCancel">Cancel</button>
        <button class="btn btn-primary" @onclick="HandleSubmit">Save</button>
    </DialogActions>
</CustomDialog>

@code {
    [Parameter]
    public CardLine Line { get; set; }
    [Parameter]
    public EventCallback<string> OnClose { get; set; }


    List<RegexPatternDisplaySegment> _patternSegments = new();
    string _currentTypingText = "";
    string _renderedRegex = "";
    List<Match> _currentMatches = new List<Match>();
    TokenTemplatePreview _tokenTemplatePreview;

    bool _isDropdownVisible = false;
    List<Type> _allTemplateTypes = new();
    List<Type> _autocompleteSuggestions = new();
    int _selectedSuggestionIndex = -1;
    ElementReference _inputElement;

    // Computed property for the full regex string
    private string _newRegexPattern => string.Concat(_patternSegments.Select(s => s.OriginalText));

    protected override void OnInitialized()
    {
        _allTemplateTypes.AddRange(TokenTypeRegistry.AppliedOrderTypes);
        _allTemplateTypes.AddRange(TokenTypeRegistry.ReferencedEnumTypes);
        _allTemplateTypes = _allTemplateTypes.OrderBy(t => t.Name).ToList();

        // In a real scenario, you would populate the initial pattern from `Line` here.
        // For now, it starts empty.
        PopulateSegmentsFromString("");
        UpdateAndRender();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JsRuntime.InvokeVoidAsync("initializeAutocompleteInteraction", "autocomplete-dropdown-list");
            await JsRuntime.InvokeVoidAsync("registerDialogKeyListener", DotNetObjectReference.Create(this));
            await JsRuntime.InvokeVoidAsync("focusElement", "regex-ghost-input");
        }
    }

    private void PopulateSegmentsFromString(string pattern)
    {
        _patternSegments.Clear();
        if (string.IsNullOrEmpty(pattern)) return;

        var regex = new Regex("(@[a-zA-Z0-9_]+)");
        var parts = regex.Split(pattern);

        foreach (var part in parts)
        {
            if (string.IsNullOrEmpty(part)) continue;

            var isPill = regex.IsMatch(part);
            _patternSegments.Add(new RegexPatternDisplaySegment(part, isPill));
        }
    }

    private void OnTextInput(ChangeEventArgs e)
    {
        JsRuntime.InvokeVoidAsync("setKeyboardNavigating", false);
        _currentTypingText = e.Value?.ToString() ?? "";
        var fullPatternForSuggestions = _newRegexPattern + _currentTypingText;

        int atIndex = _currentTypingText.LastIndexOf('@');
        if (atIndex != -1 && !_currentTypingText.Substring(atIndex).Contains(' '))
        {
            var filter = _currentTypingText.Substring(atIndex + 1);
            _autocompleteSuggestions = _allTemplateTypes
                .Where(t => t.Name.Contains(filter, StringComparison.OrdinalIgnoreCase))
                .OrderByDescending(t => t.Name.StartsWith(filter, StringComparison.OrdinalIgnoreCase))
                .ThenBy(t => t.Name)
                .ToList();

            _isDropdownVisible = _autocompleteSuggestions.Any();
            _selectedSuggestionIndex = -1;
        }
        else
        {
            _isDropdownVisible = false;
        }
        UpdateRenderedRegexAndMatches();
    }

    private void CommitTypingText()
    {
        if (!string.IsNullOrEmpty(_currentTypingText))
        {
            // If the text being typed contains a pending autocomplete, don't commit it.
            int atIndex = _currentTypingText.LastIndexOf('@');
            if (atIndex == -1 || _currentTypingText.Substring(atIndex).Contains(' '))
            {
                _patternSegments.Add(new RegexPatternDisplaySegment(_currentTypingText, IsPill: false));
                _currentTypingText = "";
                UpdateAndRender();
            }
        }
    }

    private async Task OnInputKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Backspace" && string.IsNullOrEmpty(_currentTypingText) && _patternSegments.Any())
        {
            var lastSegment = _patternSegments.Last();
            if (lastSegment.IsPill)
            {
                _patternSegments.RemoveAt(_patternSegments.Count - 1);
            }
            else // It's a text segment, move it to the typing area for editing.
            {
                _currentTypingText = lastSegment.OriginalText;
                _patternSegments.RemoveAt(_patternSegments.Count - 1);
            }
            UpdateAndRender();
            return;
        }

        if (!_isDropdownVisible) return;

        switch (e.Key)
        {
            case "ArrowDown":
            case "ArrowUp":
                await JsRuntime.InvokeVoidAsync("setKeyboardNavigating", true);
                if (e.Key == "ArrowDown")
                    _selectedSuggestionIndex = (_selectedSuggestionIndex + 1) % _autocompleteSuggestions.Count;
                else
                    _selectedSuggestionIndex = (_selectedSuggestionIndex - 1 + _autocompleteSuggestions.Count) % _autocompleteSuggestions.Count;
                await JsRuntime.InvokeVoidAsync("scrollToElement", $"autocomplete-item-{_selectedSuggestionIndex}");
                break;
            case "Enter" or "Tab":
                if (_selectedSuggestionIndex != -1)
                {
                    await SelectSuggestion(_autocompleteSuggestions[_selectedSuggestionIndex]);
                }
                break;
            case "Escape":
                _isDropdownVisible = false;
                break;
        }
    }

    private async Task SelectSuggestion(Type selection)
    {
        int atIndex = _currentTypingText.LastIndexOf('@');
        string pretext = _currentTypingText.Substring(0, atIndex);
        if (!string.IsNullOrEmpty(pretext))
        {
            _patternSegments.Add(new RegexPatternDisplaySegment(pretext));
        }

        var pillText = $"@{selection.Name}";
        //_patternSegments.Add(new RegexPatternDisplaySegment { OriginalText = pillText, DisplayText = selection.Name, IsPill = true });
        _patternSegments.Add(new RegexPatternDisplaySegment(pillText, IsPill: true));

        _currentTypingText = " "; // Add a space for better UX
        _isDropdownVisible = false;
        await JsRuntime.InvokeVoidAsync("setKeyboardNavigating", false);
        UpdateAndRender();
        await FocusInputElement();
    }

    private void DeletePill(Guid segmentId)
    {
        _patternSegments.RemoveAll(s => s.Id == segmentId);
        UpdateAndRender();
        FocusInputElement();
    }

    private void UpdateAndRender()
    {
        UpdateRenderedRegexAndMatches();
        StateHasChanged();
    }

    private void UpdateRenderedRegexAndMatches()
    {
        var patternToRender = _newRegexPattern + _currentTypingText;
        if (!patternToRender.Contains("@"))
        {
            _renderedRegex = "";
            try
            {
                if (!string.IsNullOrWhiteSpace(patternToRender))
                    _currentMatches = Regex.Matches(Line.SourceText, patternToRender).Cast<Match>().ToList();
                else
                    _currentMatches.Clear();
            }
            catch (Exception) { _currentMatches.Clear(); }
            return;
        }

        try
        {
            _tokenTemplatePreview = new(patternToRender);
            _renderedRegex = _tokenTemplatePreview.RenderedRegex;
            _currentMatches = Regex.Matches(Line.SourceText, _renderedRegex).Cast<Match>().ToList();
        }
        catch (Exception)
        {
            _renderedRegex = "Error: Invalid template";
            _currentMatches.Clear();
        }
    }

    private async Task HandleSubmit()
    {
        CommitTypingText();
        await OnClose.InvokeAsync(_newRegexPattern);
    }

    private Task HandleCancel() => OnClose.InvokeAsync(null);
    private async Task FocusInputElement() => await _inputElement.FocusAsync();

    [JSInvokable]
    public Task HandleEscapeKeyPress() => HandleCancel();

    public async ValueTask DisposeAsync() { await JsRuntime.InvokeVoidAsync("disposeDialogKeyListener"); }
}