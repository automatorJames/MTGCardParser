@inject AggregateCardAnalysis Analysis

@if (PositionalToken.Token.Type.GetCustomAttribute<IgnoreInAnalysisAttribute>() is not null)
{
    @PositionalToken.Token.MatchSpan.ToStringValue()
}
else
{
    const int pixelGapPerUnderline = 4;
    var deepestLevel = PositionalToken.Token.GetDeepestChildLevel();
    var padding = pixelGapPerUnderline * deepestLevel + pixelGapPerUnderline;
    var color = Analysis.TypeColors[PositionalToken.Token.Type];

    <span class="nested-underline" style=@($"--underline-color: {color}; padding-bottom: {padding}px;") data-capture-ids="@AllCaptureIds">
        @if (!PositionalToken.Children.Any())
        {
            <PropCapturedText 
            TextSegment=@PositionalToken.Token.MatchSpan.ToStringValue()
            SegmentAbsoluteStart=@PositionalToken.Token.MatchSpan.Position.Absolute
            ParentToken=@PositionalToken.Token
            AllCaptureIds="@AllCaptureIds" />
        }
        else
        {
            int currentIndexInParentText = 0;
            foreach (var child in PositionalToken.Children)
            {
                var childSpan = child.Token.MatchSpan;
                int childRelativeStart = childSpan.Position.Absolute - PositionalToken.Token.MatchSpan.Position.Absolute;

                // a) Render prefix text
                if (childRelativeStart > currentIndexInParentText)
                {
                    int prefixLength = childRelativeStart - currentIndexInParentText;
                    string prefixText = PositionalToken.Token.MatchSpan.Source!.Substring(PositionalToken.Token.MatchSpan.Position.Absolute + currentIndexInParentText, prefixLength);
                    <PropCapturedText TextSegment=@prefixText
                    SegmentAbsoluteStart=@(PositionalToken.Token.MatchSpan.Position.Absolute + currentIndexInParentText)
                    ParentToken=@PositionalToken.Token
                    AllCaptureIds=@AllCaptureIds />
                }

                // b) Render the child recursively
                <NestedTokenSpan PositionalToken=@child AncestorIds="@AllCaptureIds" />

                // c) Update position
                currentIndexInParentText = childRelativeStart + childSpan.Length;
            }

            // d) Render suffix text
            if (currentIndexInParentText < PositionalToken.Token.MatchSpan.Length)
            {
                int suffixLength = PositionalToken.Token.MatchSpan.Length - currentIndexInParentText;
                string suffixText = PositionalToken.Token.MatchSpan.Source!.Substring(PositionalToken.Token.MatchSpan.Position.Absolute + currentIndexInParentText, suffixLength);
                <PropCapturedText TextSegment=@suffixText
                                  SegmentAbsoluteStart=@(PositionalToken.Token.MatchSpan.Position.Absolute + currentIndexInParentText)
                                  ParentToken=@PositionalToken.Token
                                  AllCaptureIds="@AllCaptureIds" />
            }
        }
    </span>
}

@code {
    [Parameter, EditorRequired]
    public PositionalToken PositionalToken { get; set; } = default!;

    [Parameter]
    public string AncestorIds { get; set; } = "";

    private string AllCaptureIds => $"{AncestorIds} {PositionalToken.CaptureId}".Trim();
}