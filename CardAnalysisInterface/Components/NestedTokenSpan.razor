@inject AggregateCardAnalysis Analysis

@if (PositionalToken.Token.Type.GetCustomAttribute<IgnoreInAnalysisAttribute>() is not null)
{
    @PositionalToken.Token.MatchSpan.ToStringValue()
}
else
{
    const int pixelGapPerUnderline = 4;
    var deepestLevel = PositionalToken.Token.GetDeepestChildLevel();
    var padding = pixelGapPerUnderline * deepestLevel + pixelGapPerUnderline;
    var color = Analysis.TypeColors[PositionalToken.Token.Type];

    <span class="nested-underline" style=@($"--underline-color: {color}; padding-bottom: {padding}px;") data-capture-ids="@AllCaptureIds">
        @foreach (var segment in PositionalToken.Segments)
        {
            @switch (segment)
            {
                case TokenSegmentLeaf tokenSegmentLeaf:
                    <PropCapturedText 
                        TextSegment=@tokenSegmentLeaf.Text
                        SegmentAbsoluteStart=@tokenSegmentLeaf.AbsoluteStart
                        ParentToken=@PositionalToken.Token
                        AllCaptureIds="@AllCaptureIds" />
                    break;

                case TokenSegmentBranch tokenSegmentBranch:
                    <NestedTokenSpan 
                        PositionalToken=@tokenSegmentBranch.ChildToken
                        AncestorIds="@AllCaptureIds" />
                    break;
            }
        }
    </span>
}

@code {
    [Parameter, EditorRequired]
    public PositionalToken PositionalToken { get; set; } = default!;

    [Parameter]
    public string AncestorIds { get; set; } = "";

    private string AllCaptureIds => $"{AncestorIds} {PositionalToken.CaptureId}".Trim();
}