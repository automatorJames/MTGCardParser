@inject AggregateCardAnalysis Analysis

@if (string.IsNullOrEmpty(TextSegment) || !ParentToken.PropMatches.Any())
{
    @TextSegment
}
else
{
    var items = ParentToken.PropMatches.ToList();
    int currentIndexInSegment = 0;
    for (int i = 0; i < ParentToken.PropMatches.Count; i++)
    {
        var propMatch = items[i];
        var captureProp = propMatch.Key;
        var span = propMatch.Value;

        if (span.Position.Absolute >= SegmentAbsoluteStart && span.Position.Absolute < SegmentAbsoluteStart + TextSegment.Length)
        {
            int propRelativeStart = span.Position.Absolute - SegmentAbsoluteStart;

            // 1. Render text before
            if (propRelativeStart > currentIndexInSegment)
            {
                @TextSegment.Substring(currentIndexInSegment, propRelativeStart - currentIndexInSegment)
            }

            // 2. Render the property capture
            string propColor = Analysis.PropertyCaptureColors[i % Analysis.PropertyCaptureColors.Count];
            string propText = span.ToStringValue();

            <span class="prop-capture" style=@($"--prop-color: {propColor};") data-capture-ids=@AllCaptureIds data-property-name=@captureProp.Name>
                @propText
            </span>

            // 3. Update position
            currentIndexInSegment = propRelativeStart + span.Length;
        }
    }

    // Render remaining text
    if (currentIndexInSegment < TextSegment.Length)
    {
        @TextSegment.Substring(currentIndexInSegment)
    }
}

@code {
    [Parameter, EditorRequired]
    public string TextSegment { get; set; } = default!;

    [Parameter, EditorRequired]
    public int SegmentAbsoluteStart { get; set; }

    [Parameter, EditorRequired]
    public TokenUnit ParentToken { get; set; } = default!;

    [Parameter, EditorRequired]
    public string AllCaptureIds { get; set; } = default!;
}