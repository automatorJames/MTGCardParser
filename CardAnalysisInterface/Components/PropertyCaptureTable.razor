@inject AggregateCardAnalysis Analysis

<div class="property-table-wrapper">
    <span data-path=@PositionalToken.Path
    class="token-type-name"
    style=@PositionalToken.Palette.ToColorStyle()>
        @PositionalToken.Token.Type.Name.ToFriendlyCase(TitleDisplayOption.Sentence)
    </span>

    <div class="content-box" data-path=@PositionalToken.Path style=@PositionalToken.Palette.ToColorStyle(-1))>

        @if (PositionalToken.PropVals.Any())
        {
            <table class="property-capture-table" data-path=@PositionalToken.Path>
                <thead>
                    <tr><th>Property</th><th>Type</th><th>Value</th></tr>
                </thead>
                <tbody>
                    @foreach (var propVal in PositionalToken.PropVals)
                    {
                        <tr>
                            <td data-path=@propVal.Path
                            class="prop-capture-table-cell"
                            style=@propVal.Palette.ToColorStyle()>
                                @propVal.RegexPropInfo.UndistilledNameOrName.ToFriendlyCase(TitleDisplayOption.Sentence)
                            </td>

                            <td class="@GetCssClass(propVal.RegexPropInfo)">@GetFriendlyTypeName(propVal.RegexPropInfo.UnderlyingType)</td>
                            <td>@propVal.ValueAsString</td>
                        </tr>
                    }
                </tbody>
            </table>
        }

        @* The recursive children are now INSIDE the content-box, so the vertical line contains them. *@
        @foreach (var child in PositionalToken.ChildTokens)
        {
            if (child.IsTransparentInAnalysisDisplay)
            {
                foreach (var grandchild in child.ChildTokens)
                {
                    <PropertyCaptureTable PositionalToken=@grandchild />
                }
            }
            else
            {
                <PropertyCaptureTable PositionalToken=@child />
            }
        }
    </div>
</div>


@code {
    [Parameter, EditorRequired]
    public PositionalToken PositionalToken { get; set; } = default!;

    string GetCssClass(RegexPropInfo regexPropInfo)
    {
        var defaultVal = "value-default";

        if (regexPropInfo.UndistilledProp != null)
            return defaultVal;

        var capturePropType = regexPropInfo.RegexPropType;

        return regexPropInfo.RegexPropType switch
        {
            RegexPropType.Placeholder => "value-tokensegment",
            RegexPropType.Enum => "value-enum",
            _ => defaultVal
        };
    }

    string GetFriendlyTypeName(Type type)
    {
        bool isNullableEnum = type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) && type.GetGenericArguments()[0].IsEnum;
        if (type.IsEnum || isNullableEnum) return "Enum";
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) return $"{type.GetGenericArguments()[0].Name}?";
        if (type.IsAssignableTo(typeof(TokenUnit))) return "Token Unit";
        return type.Name;
    }
}