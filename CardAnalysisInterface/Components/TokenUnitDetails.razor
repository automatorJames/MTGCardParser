@inject AggregateCardAnalysis Analysis

@if (_visibleScalarPropValues.Any() || PositionalToken.Token.DistilledValues.Any())
{
    <table>
        <thead>
            <tr><th>Property</th><th>Type</th><th>Value</th></tr>
        </thead>
        <tbody>
            @{
                var keys = _visibleScalarPropValues.Keys.ToList();
            }

            @for (int i = 0; i < _visibleScalarPropValues.Count; i++)
            {
                var key = keys[i];
                var value = _visibleScalarPropValues[key];
                string propColor = Analysis.PropertyCaptureColors[i % Analysis.PropertyCaptureColors.Count];
                string valueClass = GetCssClass(key);
                <tr data-property-name=@(key.Name) data-capture-id=@PositionalToken.CaptureId>
                    <td><span style=@($"color: {propColor}; font-weight: bold;")>@key.Name</span></td>
                    <td class="@valueClass">@GetFriendlyTypeName(key.Prop.PropertyType)</td>

                    @if(key.CapturePropType == RegexPropType.TokenUnit)
                    {
                        <td class="value-empty">(below)</td>
                    }
                    else if (value == null || (value is string s && string.IsNullOrEmpty(s)))
                    {
                        <td class="value-empty">(empty)</td>
                    }
                    else
                    {
                        <td class="@valueClass">@value.ToString()</td>
                    }
                </tr>
            }

            @foreach (var distilledValueItem in PositionalToken.Token.DistilledValues)
            {
                <tr data-property-name=@(distilledValueItem.Key.Name) data-capture-id=@(PositionalToken.CaptureId)>
                    <td><span style=@($"color: #888; font-weight: bold;")>@distilledValueItem.Key.Name</span></td>
                    <td class="value-default">@GetFriendlyTypeName(distilledValueItem.Key.PropertyType)</td>
                    <td class=value-default>@distilledValueItem.Value.ToString()</td>
                </tr>
            }
        </tbody>
    </table>
}

@foreach (var child in PositionalToken.Children)
{
    <div class="property-child-block">
        <h5 data-property-name=@(child.Token.Type.Name) data-capture-id=@child.CaptureId style=@($"color: {Analysis.TypeColors[child.Token.Type]};")>@child.Token.Type.Name</h5>
        <TokenUnitDetails PositionalToken=@child />
    </div>
}


@code {
    [Parameter, EditorRequired]
    public PositionalToken PositionalToken { get; set; } = default!;

    [Parameter]
    public bool OmitCapturedTextSegmentProperties { get; set; } = true;

    Dictionary<CaptureProp, object?> _visibleScalarPropValues = new(new CapturePropComparer());

    protected override void OnInitialized()
    {
        var orderedCaptureProps = PositionalToken.Token
            .GetRegexTemplate()
            .GetOrderedCaptureProps()
            .Where(x => x.CapturePropType != RegexPropType.TokenUnit)
            .ToList();

        foreach (var captureProp in orderedCaptureProps)
        {
            var prop = captureProp.Prop;
            var value = prop.GetValue(PositionalToken.Token);

            if (value == null) continue;
            if (OmitCapturedTextSegmentProperties && prop.ProTextPlaceholder(CapturedTextSegment)) continue;
            if (prop.PropertyType.IsValueType && value.Equals(Activator.CreateInstance(prop.PropertyType))) continue;

            _visibleScalarPropValues[captureProp] = value;
        }
    }

    public string GetCssClass(CaptureProp captureProp)
    {
        var capturePropType = captureProp.CapturePropType;

        return captureProp.CapturePropType switch
        {
            RegexPropType.TextPlaceholder => "value-tokensegment",
            RegexPropType.Enum => "value-enum",
            _ => "value-default"
        };
    }

    public string GetFriendlyTypeName(Type type)
    {
        bool isNullableEnum = type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) && type.GetGenericArguments()[0].IsEnum;
        if (type.IsEnum || isNullableEnum) return "Enum";
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) return $"{type.GetGenericArguments()[0].Name}?";
        if (type.IsAssignableTo(typeof(TokenUnit))) return "Token Unit";
        return type.Name;
    }
}