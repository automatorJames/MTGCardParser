@inject AggregateCardAnalysis Analysis

@if (_visibleScalarPropValues.Any() || PositionalToken.Token.DistilledValues.Any())
{
    <table>
        <thead>
            <tr><th>Property</th><th>Type</th><th>Value</th></tr>
        </thead>
        <tbody>
            @{
                var keys = _visibleScalarPropValues.Keys.ToList();
            }

            @for (int i = 0; i < _visibleScalarPropValues.Count; i++)
            {
                var key = keys[i];
                var value = _visibleScalarPropValues[key];
                string propColor = Analysis.PropertyCaptureColors[i % Analysis.PropertyCaptureColors.Count];
                string valueClass = GetCssClass(key);
                <tr 
                style=@($"--highlight-color: {propColor};") 
                data-property-name=@(key.Name) 
                data-capture-id=@PositionalToken.CaptureId>
                    <td><span style=@($"color: {propColor}; font-weight: bold;")>@key.Name</span></td>
                    <td class=@valueClass>@GetFriendlyTypeName(key.Prop.PropertyType)</td>

                    @if(key.RegexPropType == RegexPropType.TokenUnit)
                    {
                        <td class="value-empty">(below)</td>
                    }
                    else if (value == null || (value is string s && string.IsNullOrEmpty(s)))
                    {
                        <td class="value-empty">(empty)</td>
                    }
                    else
                    {
                        <td class="@valueClass">@value.ToString()</td>
                    }
                </tr>
            }

            @foreach (var distilledValueItem in PositionalToken.Token.DistilledValues)
            {
                <tr 
                style=@($"--highlight-color: #aaa")
                data-property-name=@PositionalToken.CaptureId
                data-capture-id=@PositionalToken.CaptureId>
                    <td><span style=@($"font-weight: bold; color: #aaa")>@distilledValueItem.Key.Name</span></td>
                    <td class="value-default">@GetFriendlyTypeName(distilledValueItem.Key.PropertyType)</td>
                    <td class=value-default>@distilledValueItem.Value.ToString()</td>
                </tr>
            }
        </tbody>
    </table>
}

@foreach (var child in PositionalToken.ChildTokens)
{
    <div class="property-child-block" @key=@child.CaptureId>
        <h5 data-property-name=@(child.Token.Type.Name) data-capture-id=@child.CaptureId style=@($"color: {Analysis.TypeColors[child.Token.Type]}; --highlight-color: {Analysis.TypeColors[child.Token.Type]};")>@child.Token.Type.Name</h5>
        <TokenUnitDetails PositionalToken=@child @key=@child.CaptureId />
    </div>
}


@code {
    [Parameter, EditorRequired]
    public PositionalToken PositionalToken { get; set; } = default!;

    Dictionary<RegexPropInfo, object> _visibleScalarPropValues = new(new CapturePropComparer());

    protected override void OnInitialized()
    {
        var orderedRegexProps = PositionalToken.Token
            .Template
            .OrderedProps
            .Where(x => x.RegexPropType != RegexPropType.TokenUnit)
            .ToList();

        foreach (var captureProp in orderedRegexProps)
        {
            var prop = captureProp.Prop;
            var value = prop.GetValue(PositionalToken.Token);

            if (value == null) continue;
            if (PositionalToken.IsComplex && captureProp.RegexPropType == RegexPropType.Placeholder) continue;

            _visibleScalarPropValues[captureProp] = value;
        }
    }

    public string GetCssClass(RegexPropInfo regexPropInfo)
    {
        var capturePropType = regexPropInfo.RegexPropType;

        return regexPropInfo.RegexPropType switch
        {
            RegexPropType.Placeholder => "value-tokensegment",
            RegexPropType.Enum => "value-enum",
            _ => "value-default"
        };
    }

    public string GetFriendlyTypeName(Type type)
    {
        bool isNullableEnum = type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) && type.GetGenericArguments()[0].IsEnum;
        if (type.IsEnum || isNullableEnum) return "Enum";
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) return $"{type.GetGenericArguments()[0].Name}?";
        if (type.IsAssignableTo(typeof(TokenUnit))) return "Token Unit";
        return type.Name;
    }
}