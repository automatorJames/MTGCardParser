@inject AggregateCardAnalysis Analysis

@if (_visibleScalarPropValues.Any() || _distilledValues.Any())
{
    <table>
        <thead>
            <tr><th>Property</th><th>Type</th><th>Value</th></tr>
        </thead>
        <tbody>
            @{
                var keys = _visibleScalarPropValues.Keys.ToList();
            }

            @for (int i = 0; i < _visibleScalarPropValues.Count; i++)
            {
                var key = keys[i];
                var value = _visibleScalarPropValues[key];
                string propColor = Analysis.PropertyCaptureColors[i % Analysis.PropertyCaptureColors.Count];
                string valueClass = GetCssClass(key);
                <tr data-property-name=@(key.Name) data-capture-id=@(CaptureId)>
                    <td><span style=@($"color: {propColor}; font-weight: bold;")>@key.Name</span></td>
                    <td class="@valueClass">@GetFriendlyTypeName(key.Prop.PropertyType)</td>

                    @if(key.CapturePropType == CapturePropType.TokenUnit)
                    {
                        <td class="value-empty">(below)</td>
                    }
                    else if (value == null || (value is string s && string.IsNullOrEmpty(s)))
                    {
                        <td class="value-empty">(empty)</td>
                    }
                    else
                    {
                        <td class="@valueClass">@value.ToString()</td>
                    }
                </tr>
            }

            @foreach (var distilledValueItem in _distilledValues)
            {
                <tr data-property-name=@(distilledValueItem.Key.Name) data-capture-id=@(CaptureId)>
                    <td><span style=@($"color: #888; font-weight: bold;")>@distilledValueItem.Key.Name</span></td>
                    <td class="value-default">@GetFriendlyTypeName(distilledValueItem.Key.PropertyType)</td>
                    <td class=value-default>@distilledValueItem.Value.ToString()</td>
                </tr>
            }
        </tbody>
    </table>
}

@foreach (var (childToken, i) in Instance.ChildTokens.OrderBy(c => c.MatchSpan.Position.Absolute).Select((token, index) => (token, index)))
{
    var childCaptureId = $"{CaptureId}-child{i}";
    <div class="property-child-block">
        <h5 data-property-name=@(childToken.Type.Name) data-capture-id=@childCaptureId style=@($"color: {Analysis.TypeColors[childToken.Type]};")>@childToken.Type.Name</h5>
        <TokenUnitDetails Instance=@childToken CaptureId=@childCaptureId />
    </div>
}


@code {
    [Parameter, EditorRequired]
    public TokenUnit Instance { get; set; } = default!;

    [Parameter, EditorRequired]
    public string CaptureId { get; set; } = default!;

    [Parameter]
    public bool OmitCapturedTextSegmentProperties { get; set; } = true;

    Dictionary<CaptureProp, object?> _visibleScalarPropValues = new(new CapturePropComparer());
    Dictionary<PropertyInfo, object> _distilledValues = new();

    protected override void OnInitialized()
    {
        var orderedCaptureProps = Instance.GetRegexTemplate()
            .GetOrderedCaptureProps()
            .Where(x => x.CapturePropType != CapturePropType.TokenUnit)
            .ToList();

        foreach (var captureProp in orderedCaptureProps)
        {
            var prop = captureProp.Prop;
            var value = prop.GetValue(Instance);

            if (value == null) continue;
            if (OmitCapturedTextSegmentProperties && prop.PropertyType == typeof(CapturedTextSegment)) continue;
            if (prop.PropertyType.IsValueType && value.Equals(Activator.CreateInstance(prop.PropertyType))) continue;

            _visibleScalarPropValues[captureProp] = value;
        }

        _distilledValues = Instance.GetDistilledValues();
    }

    public string GetCssClass(CaptureProp captureProp)
    {
        var capturePropType = captureProp.CapturePropType;

        return captureProp.CapturePropType switch
        {
            CapturePropType.CapturedTextSegment => "value-tokensegment",
            CapturePropType.Enum => "value-enum",
            _ => "value-default"
        };
    }

    public string GetFriendlyTypeName(Type type)
    {
        bool isNullableEnum = type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) && type.GetGenericArguments()[0].IsEnum;
        if (type.IsEnum || isNullableEnum) return "Enum";
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) return $"{type.GetGenericArguments()[0].Name}?";
        if (type.IsAssignableTo(typeof(TokenUnit))) return "Token Unit";
        return type.Name;
    }
}