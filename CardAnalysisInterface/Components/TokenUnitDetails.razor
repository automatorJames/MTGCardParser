@inject CardTextAnalyzer Analyzer

@if (visibleScalarProps.Any())
{
    <table>
        <thead>
            <tr><th>Property</th><th>Type</th><th>Value</th></tr>
        </thead>
        <tbody>
            @foreach (var (prop, value) in visibleScalarProps)
            {
                string propColor = PropertyColorMap.GetValueOrDefault(prop.Name, "inherit");
                string valueClass = GetValueCssClass(prop.PropertyType);
                <tr data-property-name="@prop.Name" data-capture-id="@CaptureId">
                    <td><span style="color: @propColor; font-weight: bold;">@prop.Name</span></td>
                    <td class="@valueClass">@GetFriendlyTypeName(prop.PropertyType)</td>
                    @if (value == null || (value is string s && string.IsNullOrEmpty(s)))
                    {
                        <td class="value-empty">(empty)</td>
                    }
                    else
                    {
                        <td class="@valueClass">@value.ToString()</td>
                    }
                </tr>
            }
        </tbody>
    </table>
}

@foreach (var (prop, value) in childTokenUnitProperties)
{
    <div class="property-child-block">
        @{ string propColor = PropertyColorMap.GetValueOrDefault(prop.Name, "inherit"); }
        <h5 data-property-name="@prop.Name" data-capture-id="@CaptureId" style="color: @propColor;">@prop.Name</h5>
        <TokenUnitDetails Instance="value" CaptureId="@CaptureId" PropertyColorMap="PropertyColorMap" />
    </div>
}


@code {
    [Parameter, EditorRequired]
    public ITokenUnit Instance { get; set; } = default!;

    [Parameter, EditorRequired]
    public string CaptureId { get; set; } = default!;

    [Parameter, EditorRequired]
    public IReadOnlyDictionary<string, string> PropertyColorMap { get; set; } = default!;

    [Parameter]
    public bool OmitCapturedTextSegmentProperties { get; set; } = true;

    private List<(PropertyInfo prop, object? value)> visibleScalarProps = new();
    private List<(PropertyInfo prop, ITokenUnit value)> childTokenUnitProperties = new();

    protected override void OnInitialized()
    {
        var instanceType = Instance.GetType();
        var allProperties = instanceType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .Where(p => p.Name != "RegexTemplate" && p.CanRead)
            .ToDictionary(p => p.Name);

        var orderedPropNames = Instance.GetRegexTemplate()
            .GetOrderedCaptureProps()
            .Select(p => p.Name)
            .Distinct()
            .ToList();
        
        // Add any remaining properties not in the template
        foreach (var propName in allProperties.Keys.Where(k => !orderedPropNames.Contains(k)))
        {
            orderedPropNames.Add(propName);
        }

        foreach (var propName in orderedPropNames)
        {
            if (!allProperties.TryGetValue(propName, out var prop)) continue;
            
            var value = prop.GetValue(Instance);
            if (value == null) continue;

            if (typeof(ITokenUnit).IsAssignableFrom(prop.PropertyType))
            {
                childTokenUnitProperties.Add((prop, (ITokenUnit)value));
            }
            else
            {
                if (OmitCapturedTextSegmentProperties && prop.PropertyType == typeof(CapturedTextSegment)) continue;
                if (prop.PropertyType.IsValueType && value.Equals(Activator.CreateInstance(prop.PropertyType))) continue;
                
                visibleScalarProps.Add((prop, value));
            }
        }
    }

    public string GetValueCssClass(Type type)
    {
        if (type == typeof(CapturedTextSegment)) return "value-tokensegment";
        bool isEnum = type.IsEnum || (Nullable.GetUnderlyingType(type)?.IsEnum ?? false);
        if (isEnum) return "value-enum";
        return "value-default";
    }

    public string GetFriendlyTypeName(Type type)
    {
        bool isNullableEnum = type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) && type.GetGenericArguments()[0].IsEnum;
        if (type.IsEnum || isNullableEnum) return "Enum";
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) return $"{type.GetGenericArguments()[0].Name}?";
        return type.Name;
    }
}