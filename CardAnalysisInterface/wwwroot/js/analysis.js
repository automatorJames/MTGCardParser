/**
 * analysis.js
 *
 * This script provides interactivity for the MTG Card Analysis Blazor app.
 * It is loaded globally and attaches event listeners to the document body,
 * using event delegation to handle clicks and hovers efficiently.
 *
 * It relies on specific CSS classes and `data-*` attributes being present in the
 * HTML generated by the Blazor components.
 */
document.addEventListener('DOMContentLoaded', () => {

    //=========================================================================
    // SECTION 1: "CLICK TO COPY" LOGIC
    // Handles copying text from tables and <pre> tags to the clipboard.
    //=========================================================================
    document.body.addEventListener('click', (event) => {
        // Find the nearest ancestor that is a <pre> or <td> tag.
        let target = event.target.closest('pre, td');
        if (!target) return;

        // On the variable capture page, we have special rules.
        if (document.body.classList.contains('page-variable-capture')) {
            // Only allow copying from the <pre> tag with the full original text.
            // This prevents accidental copying when interacting with the analysis blocks.
            if (!target.classList.contains('full-original-text')) {
                return;
            }
        }

        // Get the text to copy. Use 'data-original-text' if available (for Card Coverage),
        // otherwise fall back to the visible inner text.
        let textToCopy = (target.tagName === 'TD' && target.hasAttribute('data-original-text'))
            ? target.getAttribute('data-original-text')
            : target.innerText.trim();

        if (textToCopy) {
            // Feature: If the user is NOT holding the Shift key, convert the text to lowercase.
            if (!event.shiftKey) {
                textToCopy = textToCopy.toLowerCase();
            }

            // Use the modern async clipboard API.
            navigator.clipboard.writeText(textToCopy).then(() => {
                // On success, show a visual "Copied" feedback message near the cursor.
                showCopyFeedback(event.clientX, event.clientY);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
    });

    // A reusable element and timeout for the "Copied" feedback popup.
    let feedbackDiv = null;
    let feedbackTimeout = null;

    function showCopyFeedback(x, y) {
        // Create the feedback div if it doesn't exist yet.
        if (!feedbackDiv) {
            feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'copy-feedback';
            feedbackDiv.textContent = 'Copied';
            document.body.appendChild(feedbackDiv);
        }

        // Reset any existing fade-out timer.
        clearTimeout(feedbackTimeout);

        // Position the popup near the mouse cursor.
        feedbackDiv.style.left = `${x + 15}px`;
        feedbackDiv.style.top = `${y + 15}px`;
        feedbackDiv.style.opacity = '1';

        // Set a new timer to fade the element out after a short duration.
        feedbackTimeout = setTimeout(() => { feedbackDiv.style.opacity = '0'; }, 1200);
    }


    //=========================================================================
    // SECTION 2: "VARIABLE CAPTURE" PAGE HOVER LOGIC
    // This is the core logic for linking highlighted text spans with their
    // corresponding details blocks on the variable capture page.
    //=========================================================================

    // Only run this logic if we are on the correct page.
    if (document.body.classList.contains('page-variable-capture')) {
        const mainContent = document.getElementById('main-content');

        // State variables to track the currently hovered elements to prevent
        // unnecessary DOM updates on every mouse move.
        let lastCaptureId = null;
        let lastPropertyName = null;

        // Use 'mouseover' with event delegation on the main content area.
        mainContent.addEventListener('mouseover', (event) => {
            // Find the closest element that has a 'data-capture-id'. This links a
            // text span to its details block.
            const target = event.target.closest('[data-capture-id]');
            const captureId = target ? target.dataset.captureId : null;

            // Also check if a specific property is being hovered.
            const propertyName = target ? target.dataset.propertyName : null;

            // --- Part A: Handle the main effect highlight (links text and details block) ---
            if (captureId !== lastCaptureId) {
                // If we've moved off a highlighted effect, clean up the old highlights.
                if (lastCaptureId) {
                    document.querySelectorAll(`[data-capture-id='${lastCaptureId}']`).forEach(el => el.classList.remove('highlight-active'));
                }
                // If we've moved onto a new effect, apply new highlights.
                if (captureId) {
                    const span = document.querySelector(`.nested-underline[data-capture-id='${captureId}']`);
                    const block = document.querySelector(`.effect-details-block[data-capture-id='${captureId}']`);
                    if (span && block) {
                        // Get the color from the text span's CSS variable.
                        const mainColor = span.style.getPropertyValue('--underline-color');

                        // Apply the active class for visual feedback (brightness).
                        span.classList.add('highlight-active');
                        block.classList.add('highlight-active');

                        // Set the color on the details block so its ::before shadow can use it.
                        block.style.setProperty('--highlight-color', mainColor);
                    }
                }
            }

            // --- Part B: Handle the specific property highlight (links overline and table row) ---
            if (propertyName !== lastPropertyName || captureId !== lastCaptureId) {
                // Clean up previous property highlights.
                if (lastCaptureId) {
                    const oldBlock = document.querySelector(`.effect-details-block[data-capture-id='${lastCaptureId}']`);
                    if (oldBlock) {
                        oldBlock.querySelectorAll('.property-highlight').forEach(el => el.classList.remove('property-highlight'));
                        // Remove the specific inline highlight on the text span.
                        document.querySelectorAll('.prop-highlight-inline').forEach(el => el.classList.remove('prop-highlight-inline'));
                    }
                }
                // Apply new property highlights.
                if (captureId && propertyName) {
                    const newBlock = document.querySelector(`.effect-details-block[data-capture-id='${captureId}']`);
                    const propSpanInText = document.querySelector(`.prop-capture[data-capture-id='${captureId}'][data-property-name='${propertyName}']`);

                    if (newBlock && propSpanInText) {
                        // Get the color from the property span in the text.
                        const propColor = propSpanInText.style.getPropertyValue('--prop-color');

                        // Highlight all matching elements in the details table (row, header).
                        newBlock.querySelectorAll(`[data-property-name='${propertyName}']`).forEach(el => {
                            el.classList.add('property-highlight');
                            el.style.setProperty('--highlight-color', propColor);
                        });

                        // Apply the specific highlight class to the span in the text.
                        propSpanInText.classList.add('prop-highlight-inline');
                    }
                }
            }

            // Update state for the next event.
            lastCaptureId = captureId;
            lastPropertyName = propertyName;
        });

        // Use 'mouseleave' to clean everything up when the mouse leaves the content area.
        mainContent.addEventListener('mouseleave', () => {
            if (lastCaptureId) {
                // Remove all active classes.
                document.querySelectorAll('.highlight-active').forEach(el => el.classList.remove('highlight-active'));
                const block = document.querySelector(`.effect-details-block[data-capture-id='${lastCaptureId}']`);
                if (block) {
                    block.querySelectorAll('.property-highlight').forEach(el => el.classList.remove('property-highlight'));
                    document.querySelectorAll('.prop-highlight-inline').forEach(el => el.classList.remove('prop-highlight-inline'));
                }
            }
            // Reset state.
            lastCaptureId = null;
            lastPropertyName = null;
        });
    }

    //=========================================================================
    // SECTION 3: "CARD COVERAGE" PAGE TOOLTIP TOGGLE
    // Handles the on/off switch for CSS-based tooltips.
    //=========================================================================
    const tooltipToggle = document.getElementById('tooltipToggle');
    if (tooltipToggle) {
        tooltipToggle.addEventListener('change', (event) => {
            // This simply adds or removes a class on the <body>. The CSS handles the rest.
            document.body.classList.toggle('tooltips-enabled', event.target.checked)
        });
    }
});