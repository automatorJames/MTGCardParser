@page "/span-trees"
@inject IJSRuntime JSRuntime
@inject RuntimeSettings RuntimeSettings
@inject CorpusAnalyzer CorpusAnalyzer
@implements IAsyncDisposable

@if (GetFilteredSpans() is var filteredSpans && !filteredSpans.Any())
{
    <p>No spans found that meet criteria.</p>
}
else
{
    <div class="span-trees-container">
        @foreach (var (span, index) in filteredSpans.Select((value, i) => (value, i)))
        {
            <div class="span-trees-card">
                <div class="card-header">
                    <div class="header-main-info">
                        <span class="header-span-text" title="@span.Text">@span.Text</span>
                        <span class="header-stat">Occurrences: @span.MaximalSpanOccurrenceCount</span>
                        <span class="header-stat">Word Count: @span.WordCount</span>
                    </div>
                    <div class="header-card-names">
                        @for (int i = 0; i < span.ContainingCards.Length; i++)
                        {
                            var cardName = span.ContainingCards[i];
                            var cardPalette = span.PositionalPalette[i];
                            <span class="card-name-item"
                                  data-card-name=@cardName
                                  style=@($"border-color: {cardPalette.Hex}; --highlight-color: {cardPalette.HexLight};")>
                                @cardName
                            </span>
                        }
                    </div>
                </div>
                <div class="word-tree-body">
                    <div id="@($"spinner-{index}")" class="spinner"></div>
                    <div id="@($"word-tree-container-{index}")"></div>
                </div>
            </div>
        }
    </div>
}

@code {
    private List<AnalyzedSpan> _spansOnPage = new();

    protected override void OnInitialized()
    {
        RuntimeSettings.OnChanged += OnSettingsChanged;
    }

    private async void OnSettingsChanged()
    {
        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var spansToRender = GetFilteredSpans().ToList();

        if (_spansOnPage.SequenceEqual(spansToRender))
            return;

        // Clean up any old observers
        await CleanupJsObservers(_spansOnPage);

        // Track the new list
        _spansOnPage = spansToRender;

        // Kick off each render + its own spinner
        for (int i = 0; i < _spansOnPage.Count; i++)
        {
            var treeId = $"word-tree-container-{i}";
            var spinnerId = $"spinner-{i}";
            await JSRuntime.InvokeVoidAsync("renderTreeWithSpinner", treeId, spinnerId, _spansOnPage[i]);
        }
    }

    private IEnumerable<AnalyzedSpan> GetFilteredSpans()
    {
        DigestedSpanCorpus corpus = RuntimeSettings.ShowOriginalText
            ? CorpusAnalyzer.OriginalDigestedCorpus
            : CorpusAnalyzer.UnmatchedDigestedCorpus;

        var items = corpus.Spans
            .Where(x =>
                x.MaximalSpanOccurrenceCount >= RuntimeSettings.MinSpanOccurences &&
                x.WordCount >= RuntimeSettings.MinSpanWords);

        return RuntimeSettings.OrderByWordCount
            ? items.OrderByDescending(x => x.WordCount)
            : items.OrderByDescending(x => x.MaximalSpanOccurrenceCount);
    }

    private async Task CleanupJsObservers(List<AnalyzedSpan> spansToClean)
    {
        for (int i = 0; i < spansToClean.Count; i++)
        {
            var containerId = $"word-tree-container-{i}";
            try
            {
                await JSRuntime.InvokeVoidAsync("disposeTree", containerId);
            }
            catch (JSDisconnectedException)
            {
                // ignore if nav away
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        RuntimeSettings.OnChanged -= OnSettingsChanged;
        await CleanupJsObservers(_spansOnPage);
    }
}