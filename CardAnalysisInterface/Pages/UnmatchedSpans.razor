@page "/unmatched-spans"
@using MTGPlexer.TokenAnalysis
@inject IJSRuntime JSRuntime
@inject RuntimeSettings RuntimeSettings
@inject CorpusAnalyzer CorpusAnalyzer
@implements IAsyncDisposable

@if (GetFilteredUnmatchedSpans() is var filteredSpans && !filteredSpans.Any())
{
    <p>No unmatched spans found.</p>
}
else
{
    <div class="unmatched-spans-container">
        @foreach (var (span, index) in filteredSpans.Select((value, i) => (value, i)))
        {
            <div class="unmatched-spans-card" id="@($"unmatched-card-{index}")">
                <div class="card-header">
                    <div class="header-main-info">
                        <span class="header-span-text" title="@span.Text">@span.Text</span>
                        <span class="header-stat">Occurrences: @span.MaximalSpanOccurrenceCount</span>
                        <span class="header-stat">Word Count: @span.WordCount</span>
                    </div>
                    <div class="header-card-names">
                        @foreach (var cardName in span.OccurrencesPerCard.Keys)
                        {
                            var color = span.CardColors.TryGetValue(cardName, out var c) ? c : "#dddddd";
                            <span class="card-name-item"
                                  data-card-name="@cardName"
                                  style="border-color: @color;">
                                @cardName
                            </span>
                        }
                    </div>
                </div>
                <div id="@($"word-tree-container-{index}")" class="word-tree-body"></div>
            </div>
        }
    </div>
}

@code {
    // This list tracks what JS observers we have created, so we can clean them up.
    private List<AnalyzedUnmatchedSpan> _spansOnPage = new();

    protected override void OnInitialized()
    {
        // Subscribe to the settings changed event.
        RuntimeSettings.OnChanged += OnSettingsChanged;
    }

    /// <summary>
    /// This is the event handler for when the user changes a setting.
    /// Its only job is to tell Blazor that it needs to re-render the component markup.
    /// </summary>
    private async void OnSettingsChanged()
    {
        // Using InvokeAsync is the correct and safe way to trigger a UI update
        // from an external event.
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// This Blazor lifecycle method runs *after* the component's markup has been rendered or updated.
    /// This is the correct place to perform all JS interop.
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var spansToRender = GetFilteredUnmatchedSpans().ToList();

        // Check if the list of spans has actually changed. If not, we don't need
        // to do any expensive JS interop calls. Records have built-in equality.
        if (_spansOnPage.SequenceEqual(spansToRender))
        {
            return;
        }

        // The list of spans is different, so we must update the visualization.

        // 1. First, clean up all the old JavaScript observers to prevent memory leaks.
        await CleanupJsObservers(_spansOnPage);

        // 2. Now, render the new set of trees into the new divs.
        for (int i = 0; i < spansToRender.Count; i++)
        {
            var span = spansToRender[i];
            var containerId = $"word-tree-container-{i}";
            await JSRuntime.InvokeVoidAsync("renderTree", containerId, span);
        }

        // 3. Finally, update our tracking list to match what is now on the page.
        _spansOnPage = spansToRender;
    }

    private IEnumerable<AnalyzedUnmatchedSpan> GetFilteredUnmatchedSpans()
    {
        var items = CorpusAnalyzer.UnmatchedDigestedCorpus.Spans
            .Where(x => x.MaximalSpanOccurrenceCount >= RuntimeSettings.MinUnmatchedSpanOccurences && x.WordCount >= RuntimeSettings.MinUnmatchedSpanWords);

        return RuntimeSettings.OrderByWordCount
            ? items.OrderByDescending(x => x.WordCount)
            : items.OrderByDescending(x => x.MaximalSpanOccurrenceCount);
    }

    /// <summary>
    /// A helper method to tell JavaScript to dispose of the observers for a given list of spans.
    /// </summary>
    private async Task CleanupJsObservers(List<AnalyzedUnmatchedSpan> spansToClean)
    {
        for (int i = 0; i < spansToClean.Count; i++)
        {
            var containerId = $"word-tree-container-{i}";
            try
            {
                await JSRuntime.InvokeVoidAsync("disposeTree", containerId);
            }
            catch (JSDisconnectedException)
            {
                // This can happen if the user navigates away quickly. It's safe to ignore.
            }
        }
    }

    /// <summary>
    /// This is called by the Blazor framework when the component is removed from the page.
    /// </summary>
    public async ValueTask DisposeAsync()
    {
        // 1. Unsubscribe from the C# event to prevent memory leaks.
        RuntimeSettings.OnChanged -= OnSettingsChanged;

        // 2. Clean up any remaining JavaScript observers.
        await CleanupJsObservers(_spansOnPage);
    }
}