@page "/unmatched-spans"
@using MTGPlexer.TokenAnalysis
@inject IJSRuntime JSRuntime
@inject RuntimeSettings RuntimeSettings
@inject CorpusAnalyzer CorpusAnalyzer
@implements IDisposable

@if (!CorpusAnalyzer.UnmatchedDigestedCorpus.Spans.Any())
{
    <p>No unmatched spans found.</p>
}
else
{
    <div class="unmatched-spans-container">
        @foreach (var (span, index) in GetFilteredUnmatchedSpans().Select((value, i) => (value, i)))
        {
            <div id="@($"word-tree-container-{index}")" class="word-tree-card"></div>
        }
    </div>
}

@code {
    protected override void OnInitialized()
    {
        RuntimeSettings.OnChanged += StateHasChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var spansToRender = GetFilteredUnmatchedSpans().ToList();
            for (int i = 0; i < spansToRender.Count; i++)
            {
                var span = spansToRender[i];
                var containerId = $"word-tree-container-{i}";
                await JSRuntime.InvokeVoidAsync("renderTree", containerId, span);
            }
        }
    }

    private IEnumerable<AnalyzedUnmatchedSpan> GetFilteredUnmatchedSpans()
    {
        var items = CorpusAnalyzer.UnmatchedDigestedCorpus.Spans
            .Where(x => x.MaximalSpanOccurrenceCount >= RuntimeSettings.MinUnmatchedSpanOccurences && x.WordCount >= RuntimeSettings.MinUnmatchedSpanWords);

        return RuntimeSettings.OrderByWordCount
            ? items.OrderByDescending(x => x.WordCount)
            : items.OrderByDescending(x => x.MaximalSpanOccurrenceCount);
    }

    public void Dispose()
    {
        RuntimeSettings.OnChanged -= StateHasChanged;
    }
}