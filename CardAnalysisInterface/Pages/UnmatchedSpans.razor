@page "/unmatched-spans"
@using MTGPlexer.TokenAnalysis
@inject IJSRuntime JSRuntime
@inject RuntimeSettings RuntimeSettings
@inject CorpusAnalyzer CorpusAnalyzer
@implements IAsyncDisposable

@if (GetFilteredUnmatchedSpans() is var filteredSpans && !filteredSpans.Any())
{
    <p>No unmatched spans found.</p>
}
else
{
    <div class="unmatched-spans-container">
        @foreach (var (span, index) in filteredSpans.Select((value, i) => (value, i)))
        {
            <div id="@($"word-tree-container-{index}")" class="word-tree-card"></div>
        }
    </div>
}

@code {
    // Store the list of spans that are currently rendered to the page.
    private List<AnalyzedUnmatchedSpan> _renderedSpans = new();

    protected override void OnInitialized()
    {
        RuntimeSettings.OnChanged += StateHasChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Get the current list of spans that should be on the page.
        var spansToRender = GetFilteredUnmatchedSpans().ToList();

        // We only need to call JS interop if the list of spans has changed.
        // NOTE: This simple check works for additions/removals. More complex diffing
        // might be needed if the order can change without the count changing.
        if (!_renderedSpans.SequenceEqual(spansToRender))
        {
            _renderedSpans = spansToRender;
            for (int i = 0; i < _renderedSpans.Count; i++)
            {
                var span = _renderedSpans[i];
                var containerId = $"word-tree-container-{i}";
                // Call the main entry point for the JS logic.
                await JSRuntime.InvokeVoidAsync("renderTree", containerId, span);
            }
        }
    }

    private IEnumerable<AnalyzedUnmatchedSpan> GetFilteredUnmatchedSpans()
    {
        var items = CorpusAnalyzer.UnmatchedDigestedCorpus.Spans
            .Where(x => x.MaximalSpanOccurrenceCount >= RuntimeSettings.MinUnmatchedSpanOccurences && x.WordCount >= RuntimeSettings.MinUnmatchedSpanWords);

        return RuntimeSettings.OrderByWordCount
            ? items.OrderByDescending(x => x.WordCount)
            : items.OrderByDescending(x => x.MaximalSpanOccurrenceCount);
    }

    // This method is called by the Blazor framework when the component is removed.
    public async ValueTask DisposeAsync()
    {
        // Clean up the JS-side ResizeObserver for each tree that was rendered.
        for (int i = 0; i < _renderedSpans.Count; i++)
        {
            var containerId = $"word-tree-container-{i}";
            try
            {
                await JSRuntime.InvokeVoidAsync("disposeTree", containerId);
            }
            catch (JSDisconnectedException)
            {
                // The browser tab is closing, JS interop is not available. This is safe to ignore.
            }
        }

        // Unsubscribe from the C# event to prevent memory leaks.
        RuntimeSettings.OnChanged -= StateHasChanged;
    }
}